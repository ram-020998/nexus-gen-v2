"""
Appian Analyzer Service - Self-contained analyzer functionality
"""
import zipfile
import xml.etree.ElementTree as ET
import json
import os
from pathlib import Path
from typing import Dict, Any, Optional


class AppianAnalyzer:
    """Enhanced Appian application analyzer with comprehensive features"""
    
    def __init__(self, zip_path: str):
        self.zip_path = zip_path
        self.objects = {}
        self.sites = []
        self.record_types = []
        self.process_models = []
        self.interfaces = []
        self.rules = []
        self.constants = []
        self.security_groups = []
        self.connected_systems = []
        self.web_apis = []
        self.namespaces = {
            'a': 'http://www.appian.com/ae/types/2009',
            'xsd': 'http://www.w3.org/2001/XMLSchema'
        }
    
    def analyze(self) -> Dict[str, Any]:
        """Comprehensive analysis of Appian application ZIP"""
        try:
            print(f"DEBUG: Opening ZIP file: {self.zip_path}")
            with zipfile.ZipFile(self.zip_path, 'r') as zip_file:
                file_list = zip_file.filelist
                print(f"DEBUG: ZIP contains {len(file_list)} files")
                
                xml_files = [f for f in file_list if f.filename.endswith('.xml') and not f.filename.startswith('META-INF')]
                print(f"DEBUG: Found {len(xml_files)} XML files to parse")
                
                # Parse all XML files with enhanced parsing
                for file_info in xml_files:
                    print(f"DEBUG: Parsing {file_info.filename}")
                    self._parse_xml_file_enhanced(zip_file, file_info.filename)
                
                print(f"DEBUG: After parsing - objects: {len(self.objects)}, sites: {len(self.sites)}, record_types: {len(self.record_types)}")
                
                # Generate comprehensive blueprint and lookup
                blueprint = self._generate_enhanced_blueprint()
                object_lookup = self._generate_object_lookup()
                
                return {
                    "blueprint": blueprint,
                    "object_lookup": object_lookup
                }
        except Exception as e:
            print(f"DEBUG: Analysis failed with error: {str(e)}")
            raise Exception(f"Analysis failed: {str(e)}")
    
    def _parse_xml_file_enhanced(self, zip_file: zipfile.ZipFile, filename: str):
        """Enhanced XML parsing with component-specific analysis"""
        try:
            with zip_file.open(filename) as xml_file:
                tree = ET.parse(xml_file)
                root = tree.getroot()
                
                # Extract basic object info
                uuid = root.get('uuid') or root.get('id')
                name = self._extract_name(root)
                description = self._extract_description(root)
                
                if not uuid:
                    # Generate a UUID if none exists
                    uuid = f"generated_{len(self.objects)}_{filename.replace('/', '_').replace('.xml', '')}"
                
                if not name:
                    name = f"Unnamed_{filename.split('/')[-1].replace('.xml', '')}"
                
                # Create basic object entry
                basic_obj = {
                    'uuid': uuid,
                    'name': name,
                    'object_type': self._get_object_type(filename),
                    'description': description,
                    'file_path': filename
                }
                
                # Add to objects collection
                self.objects[uuid] = basic_obj
                
                # Enhanced parsing based on component type
                if 'site/' in filename:
                    self._parse_site(root, filename)
                elif 'recordType/' in filename:
                    self._parse_record_type(root, filename)
                elif 'processModel/' in filename:
                    self._parse_process_model(root, filename)
                elif 'content/' in filename:
                    self._parse_content_object(root, filename)
                elif 'group/' in filename:
                    self._parse_security_group(root, filename)
                elif 'connectedSystem/' in filename:
                    self._parse_connected_system(root, filename)
                elif 'webApi/' in filename:
                    self._parse_web_api(root, filename)
                
        except Exception as e:
            print(f"DEBUG: Failed to parse {filename}: {str(e)}")
            # Don't fail silently - still try to create a basic object
            try:
                uuid = f"error_{len(self.objects)}_{filename.replace('/', '_').replace('.xml', '')}"
                basic_obj = {
                    'uuid': uuid,
                    'name': f"ParseError_{filename.split('/')[-1].replace('.xml', '')}",
                    'object_type': self._get_object_type(filename),
                    'description': f"Failed to parse: {str(e)}",
                    'file_path': filename
                }
                self.objects[uuid] = basic_obj
            except:
                pass
    
    def _parse_site(self, root: ET.Element, filename: str):
        """Parse site objects with page hierarchy"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Count pages
        pages = root.findall('.//a:page', self.namespaces)
        page_count = len(pages)
        
        site_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Site',
            'description': description,
            'file_path': filename,
            'page_count': page_count,
            'business_domain': self._classify_business_domain(name)
        }
        
        self.sites.append(site_obj)
        if uuid:
            self.objects[uuid] = site_obj
    
    def _parse_record_type(self, root: ET.Element, filename: str):
        """Parse record types with field analysis"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Analyze fields
        fields = root.findall('.//a:field', self.namespaces)
        field_count = len(fields)
        
        # Analyze relationships
        relationships = root.findall('.//a:relationship', self.namespaces)
        relationship_count = len(relationships)
        
        # Calculate complexity
        complexity = self._calculate_record_complexity(field_count, relationship_count)
        
        record_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Record Type',
            'description': description,
            'file_path': filename,
            'field_count': field_count,
            'relationship_count': relationship_count,
            'complexity': complexity,
            'business_domain': self._classify_business_domain(name)
        }
        
        self.record_types.append(record_obj)
        if uuid:
            self.objects[uuid] = record_obj
    
    def _parse_process_model(self, root: ET.Element, filename: str):
        """Parse process models with node analysis"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Analyze nodes
        nodes = root.findall('.//a:node', self.namespaces)
        node_count = len(nodes)
        
        # Classify automation level
        automation_level = self._assess_automation_level(nodes)
        
        # Calculate complexity
        complexity = self._calculate_process_complexity(node_count)
        
        process_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Process Model',
            'description': description,
            'file_path': filename,
            'node_count': node_count,
            'automation_level': automation_level,
            'complexity': complexity,
            'business_function': self._classify_business_function(name)
        }
        
        self.process_models.append(process_obj)
        if uuid:
            self.objects[uuid] = process_obj
    
    def _parse_content_object(self, root: ET.Element, filename: str):
        """Parse content objects (interfaces, rules, constants)"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Determine specific type
        if 'interface' in filename.lower():
            obj_type = 'Interface'
            self.interfaces.append(self._create_content_obj(uuid, name, obj_type, description, filename))
        elif 'rule' in filename.lower():
            obj_type = 'Expression Rule'
            self.rules.append(self._create_content_obj(uuid, name, obj_type, description, filename))
        elif 'constant' in filename.lower():
            obj_type = 'Constant'
            self.constants.append(self._create_content_obj(uuid, name, obj_type, description, filename))
        else:
            obj_type = 'Content'
        
        if uuid:
            self.objects[uuid] = self._create_content_obj(uuid, name, obj_type, description, filename)
    
    def _create_content_obj(self, uuid: str, name: str, obj_type: str, description: str, filename: str):
        """Create content object with classification"""
        return {
            'uuid': uuid,
            'name': name,
            'object_type': obj_type,
            'description': description,
            'file_path': filename,
            'business_domain': self._classify_business_domain(name)
        }
    
    def _parse_security_group(self, root: ET.Element, filename: str):
        """Parse security groups with role classification"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Classify security group type
        group_type = self._classify_security_group_type(name)
        
        security_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Security Group',
            'description': description,
            'file_path': filename,
            'group_type': group_type,
            'business_function': self._classify_business_function(name)
        }
        
        self.security_groups.append(security_obj)
        if uuid:
            self.objects[uuid] = security_obj
    
    def _parse_connected_system(self, root: ET.Element, filename: str):
        """Parse connected systems with integration analysis"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Assess security level
        security_level = self._assess_integration_security(root)
        
        integration_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Connected System',
            'description': description,
            'file_path': filename,
            'security_level': security_level,
            'integration_pattern': self._classify_integration_pattern(name)
        }
        
        self.connected_systems.append(integration_obj)
        if uuid:
            self.objects[uuid] = integration_obj
    
    def _parse_web_api(self, root: ET.Element, filename: str):
        """Parse web APIs with endpoint analysis"""
        uuid = root.get('uuid')
        name = self._extract_name(root)
        description = self._extract_description(root)
        
        # Analyze endpoints
        endpoints = root.findall('.//a:endpoint', self.namespaces)
        endpoint_count = len(endpoints)
        
        api_obj = {
            'uuid': uuid,
            'name': name,
            'object_type': 'Web API',
            'description': description,
            'file_path': filename,
            'endpoint_count': endpoint_count,
            'api_pattern': self._classify_api_pattern(name)
        }
        
        self.web_apis.append(api_obj)
        if uuid:
            self.objects[uuid] = api_obj
    
    def _classify_business_domain(self, name: str) -> str:
        """Classify business domain based on name patterns"""
        name_lower = name.lower()
        if any(term in name_lower for term in ['user', 'person', 'employee', 'customer']):
            return 'User Management'
        elif any(term in name_lower for term in ['order', 'purchase', 'invoice', 'payment']):
            return 'Financial'
        elif any(term in name_lower for term in ['document', 'file', 'content']):
            return 'Document Management'
        elif any(term in name_lower for term in ['report', 'analytics', 'dashboard']):
            return 'Reporting'
        else:
            return 'General'
    
    def _classify_business_function(self, name: str) -> str:
        """Classify business function"""
        name_lower = name.lower()
        if any(term in name_lower for term in ['admin', 'administrator']):
            return 'Administration'
        elif any(term in name_lower for term in ['approval', 'review', 'workflow']):
            return 'Workflow Management'
        elif any(term in name_lower for term in ['data', 'sync', 'integration']):
            return 'Data Management'
        else:
            return 'Business Process'
    
    def _calculate_record_complexity(self, field_count: int, relationship_count: int) -> str:
        """Calculate record type complexity"""
        score = field_count + (relationship_count * 2)
        if score > 20:
            return 'Very High'
        elif score > 10:
            return 'High'
        elif score > 5:
            return 'Medium'
        else:
            return 'Low'
    
    def _calculate_process_complexity(self, node_count: int) -> str:
        """Calculate process model complexity"""
        if node_count > 20:
            return 'Very High'
        elif node_count > 10:
            return 'High'
        elif node_count > 5:
            return 'Medium'
        else:
            return 'Low'
    
    def _assess_automation_level(self, nodes: list) -> str:
        """Assess process automation level"""
        if len(nodes) > 15:
            return 'High Automation'
        elif len(nodes) > 8:
            return 'Medium Automation'
        else:
            return 'Low Automation'
    
    def _classify_security_group_type(self, name: str) -> str:
        """Classify security group type"""
        name_lower = name.lower()
        if 'admin' in name_lower:
            return 'Administrative'
        elif any(term in name_lower for term in ['user', 'viewer', 'reader']):
            return 'End User'
        elif 'service' in name_lower:
            return 'Service Account'
        else:
            return 'Business Role'
    
    def _assess_integration_security(self, root: ET.Element) -> str:
        """Assess integration security level"""
        # Simple assessment based on authentication elements
        auth_elements = root.findall('.//a:authentication', self.namespaces)
        if auth_elements:
            return 'High Security'
        else:
            return 'Standard Security'
    
    def _classify_integration_pattern(self, name: str) -> str:
        """Classify integration pattern"""
        name_lower = name.lower()
        if 'database' in name_lower:
            return 'Database Integration'
        elif any(term in name_lower for term in ['rest', 'api', 'web']):
            return 'REST API'
        elif 'soap' in name_lower:
            return 'SOAP Service'
        else:
            return 'Custom Integration'
    
    def _classify_api_pattern(self, name: str) -> str:
        """Classify API pattern"""
        name_lower = name.lower()
        if 'crud' in name_lower:
            return 'CRUD Operations'
        elif 'query' in name_lower:
            return 'Query API'
        else:
            return 'Custom API'
    
    def _get_object_type(self, filename: str) -> str:
        """Determine object type from file path"""
        if 'site/' in filename:
            return 'Site'
        elif 'recordType/' in filename:
            return 'Record Type'
        elif 'processModel/' in filename:
            return 'Process Model'
        elif 'content/' in filename:
            if 'interface' in filename.lower():
                return 'Interface'
            elif 'rule' in filename.lower():
                return 'Expression Rule'
            elif 'constant' in filename.lower():
                return 'Constant'
            else:
                return 'Content'
        elif 'group/' in filename:
            return 'Security Group'
        elif 'connectedSystem/' in filename:
            return 'Connected System'
        elif 'webApi/' in filename:
            return 'Web API'
        else:
            return 'Unknown'

    def _extract_name(self, root: ET.Element) -> str:
        """Extract object name from XML"""
        name_elem = root.find('.//a:name', self.namespaces)
        if name_elem is not None and name_elem.text:
            return name_elem.text
        
        display_name = root.find('.//a:displayName', self.namespaces)
        if display_name is not None and display_name.text:
            return display_name.text
        
        title = root.find('.//a:title', self.namespaces)
        if title is not None and title.text:
            return title.text
        
        return 'Unnamed'
    
    def _extract_description(self, root: ET.Element) -> str:
        """Extract object description from XML"""
        desc_elem = root.find('.//a:description', self.namespaces)
        if desc_elem is not None and desc_elem.text:
            return desc_elem.text
        return ''
    
    def _generate_enhanced_blueprint(self) -> Dict[str, Any]:
        """Generate comprehensive application blueprint"""
        app_name = Path(self.zip_path).stem
        total_objects = len(self.objects)
        
        # Enhanced complexity assessment
        complexity = self._assess_application_complexity()
        maintainability = self._assess_maintainability()
        recommendations = self._generate_recommendations()
        
        # Component breakdown with detailed analysis
        component_summary = {
            'Sites': len(self.sites),
            'Record Types': len(self.record_types),
            'Process Models': len(self.process_models),
            'Interfaces': len(self.interfaces),
            'Expression Rules': len(self.rules),
            'Constants': len(self.constants),
            'Security Groups': len(self.security_groups),
            'Connected Systems': len(self.connected_systems),
            'Web APIs': len(self.web_apis)
        }
        
        # Business domain analysis
        domain_analysis = self._analyze_business_domains()
        
        return {
            "metadata": {
                "name": app_name,
                "version": "Unknown",
                "analysis_date": "2024-11-07",
                "total_objects": total_objects,
                "analyzer_version": "2.0.0"
            },
            "executive_summary": {
                "application_type": self._determine_application_type(),
                "complexity": complexity,
                "maintainability": maintainability,
                "recommendations": recommendations,
                "key_metrics": {
                    "automation_score": self._calculate_automation_score(),
                    "integration_complexity": self._assess_integration_complexity(),
                    "security_coverage": self._assess_security_coverage()
                }
            },
            "component_summary": component_summary,
            "business_analysis": {
                "domain_distribution": domain_analysis,
                "process_automation_levels": self._analyze_automation_levels(),
                "integration_patterns": self._analyze_integration_patterns()
            },
            "detailed_components": {
                "sites": self.sites[:10],  # Limit for performance
                "record_types": self.record_types[:20],
                "process_models": self.process_models[:15],
                "security_groups": self.security_groups[:15]
            }
        }
    
    def _assess_application_complexity(self) -> str:
        """Enhanced complexity assessment"""
        total_objects = len(self.objects)
        process_complexity = sum(1 for p in self.process_models if p.get('complexity') in ['High', 'Very High'])
        integration_count = len(self.connected_systems) + len(self.web_apis)
        
        complexity_score = total_objects + (process_complexity * 10) + (integration_count * 5)
        
        if complexity_score > 3000:
            return "Very High"
        elif complexity_score > 1500:
            return "High"
        elif complexity_score > 500:
            return "Medium"
        else:
            return "Low"
    
    def _assess_maintainability(self) -> str:
        """Assess application maintainability"""
        rule_to_interface_ratio = len(self.rules) / max(len(self.interfaces), 1)
        if rule_to_interface_ratio > 3:
            return "Needs Attention"
        elif rule_to_interface_ratio > 2:
            return "Fair"
        else:
            return "Good"
    
    def _generate_recommendations(self) -> list:
        """Generate intelligent recommendations"""
        recommendations = []
        
        if len(self.rules) > len(self.interfaces) * 2:
            recommendations.append("Consider consolidating expression rules into reusable interfaces")
        
        if len(self.process_models) > 50:
            recommendations.append("Review process model architecture for potential modularization")
        
        if len(self.connected_systems) > 10:
            recommendations.append("Evaluate integration architecture for optimization opportunities")
        
        if not recommendations:
            recommendations.append("Application architecture appears well-structured")
        
        return recommendations
    
    def _determine_application_type(self) -> str:
        """Determine application type based on components"""
        if len(self.process_models) > len(self.record_types):
            return "Workflow-Centric Application"
        elif len(self.record_types) > 20:
            return "Data-Centric Application"
        elif len(self.connected_systems) > 5:
            return "Integration-Heavy Application"
        else:
            return "Business Application"
    
    def _calculate_automation_score(self) -> int:
        """Calculate automation score (0-100)"""
        if not self.process_models:
            return 0
        
        high_automation = sum(1 for p in self.process_models if p.get('automation_level') == 'High Automation')
        return min(100, (high_automation / len(self.process_models)) * 100)
    
    def _assess_integration_complexity(self) -> str:
        """Assess integration complexity"""
        integration_count = len(self.connected_systems) + len(self.web_apis)
        if integration_count > 10:
            return "High"
        elif integration_count > 5:
            return "Medium"
        else:
            return "Low"
    
    def _assess_security_coverage(self) -> str:
        """Assess security coverage"""
        if len(self.security_groups) > len(self.record_types):
            return "Comprehensive"
        elif len(self.security_groups) > 5:
            return "Adequate"
        else:
            return "Basic"
    
    def _analyze_business_domains(self) -> Dict[str, int]:
        """Analyze business domain distribution"""
        domains = {}
        for obj in self.objects.values():
            domain = obj.get('business_domain', 'General')
            domains[domain] = domains.get(domain, 0) + 1
        return domains
    
    def _analyze_automation_levels(self) -> Dict[str, int]:
        """Analyze process automation levels"""
        levels = {}
        for process in self.process_models:
            level = process.get('automation_level', 'Unknown')
            levels[level] = levels.get(level, 0) + 1
        return levels
    
    def _analyze_integration_patterns(self) -> Dict[str, int]:
        """Analyze integration patterns"""
        patterns = {}
        for system in self.connected_systems:
            pattern = system.get('integration_pattern', 'Unknown')
            patterns[pattern] = patterns.get(pattern, 0) + 1
        return patterns
    
    def _generate_object_lookup(self) -> Dict[str, Any]:
        """Generate enhanced object lookup table"""
        lookup = {}
        for i, (uuid, obj) in enumerate(self.objects.items(), 1):
            lookup[uuid] = {
                **obj,
                's_no': i,
                'security': {'roles': []}
            }
        return lookup


class AppianAnalyzerService:
    """Service to analyze Appian application ZIP files"""
    
    def __init__(self):
        self.output_dir = Path("applicationArtifacts")
        self.output_dir.mkdir(exist_ok=True)
    
    def analyze_application(self, zip_file_path: str) -> Dict[str, Any]:
        """Analyze Appian application ZIP file"""
        try:
            analyzer = AppianAnalyzer(zip_file_path)
            result = analyzer.analyze()
            
            # Extract app name from zip filename
            app_name = Path(zip_file_path).stem
            
            # Save outputs to applicationArtifacts
            app_dir = self.output_dir / app_name
            app_dir.mkdir(exist_ok=True)
            
            blueprint_file = app_dir / f"{app_name}_blueprint.json"
            lookup_file = app_dir / f"{app_name}_object_lookup.json"
            
            # Write files
            with open(blueprint_file, 'w') as f:
                json.dump(result["blueprint"], f, indent=2)
            
            with open(lookup_file, 'w') as f:
                json.dump(result["object_lookup"], f, indent=2)
            
            return {
                "success": True,
                "app_name": app_name,
                "blueprint_file": str(blueprint_file),
                "lookup_file": str(lookup_file),
                "summary": result["blueprint"].get("executive_summary", {})
            }
            
        except Exception as e:
            return {"error": f"Analysis failed: {str(e)}"}
    
    def compare_versions(self, old_zip: str, new_zip: str) -> Dict[str, Any]:
        """Compare two application versions"""
        try:
            # Analyze both versions
            old_analyzer = AppianAnalyzer(old_zip)
            new_analyzer = AppianAnalyzer(new_zip)
            
            old_result = old_analyzer.analyze()
            new_result = new_analyzer.analyze()
            
            # Simple comparison
            old_objects = set(old_result["object_lookup"].keys())
            new_objects = set(new_result["object_lookup"].keys())
            
            added = new_objects - old_objects
            removed = old_objects - new_objects
            modified = old_objects & new_objects  # Simplified - assume all common objects are modified
            
            comparison = {
                "summary": {
                    "objects_added": len(added),
                    "objects_removed": len(removed),
                    "objects_modified": len(modified)
                },
                "changes": {
                    "added": list(added)[:10],  # Limit for performance
                    "removed": list(removed)[:10],
                    "modified": list(modified)[:10]
                }
            }
            
            # Save comparison result
            old_name = Path(old_zip).stem
            new_name = Path(new_zip).stem
            comparison_file = self.output_dir / f"{old_name}_vs_{new_name}_comparison.json"
            
            with open(comparison_file, 'w') as f:
                json.dump(comparison, f, indent=2)
            
            return {
                "success": True,
                "comparison_file": str(comparison_file),
                "summary": comparison["summary"]
            }
            
        except Exception as e:
            return {"error": f"Comparison failed: {str(e)}"}
    
    def get_available_applications(self) -> list:
        """Get list of analyzed applications"""
        apps = []
        for app_dir in self.output_dir.iterdir():
            if app_dir.is_dir() and not app_dir.name.startswith('.'):
                blueprint_file = app_dir / f"{app_dir.name}_blueprint.json"
                if blueprint_file.exists():
                    apps.append({
                        "name": app_dir.name,
                        "path": str(app_dir),
                        "blueprint_file": str(blueprint_file)
                    })
        return apps
