"""
Q Agent Service - Handle Amazon Q CLI agent interactions
"""
import subprocess
import json
import tempfile
from pathlib import Path
from config import Config

class QAgentService:
    """Handle Q CLI agent operations"""
    
    def __init__(self):
        self.config = Config
    
    def process_breakdown(self, request_id: int, file_content: str, bedrock_context: dict) -> dict:
        """Process spec breakdown using Q agent"""
        try:
            # Create output path
            output_path = self.config.OUTPUT_FOLDER / str(request_id) / "breakdown_data.json"
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Create temporary file with spec content
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as temp_file:
                temp_file.write(file_content)
                temp_file_path = temp_file.name
            
            # Prepare prompt with Bedrock context
            prompt = self._create_breakdown_prompt(temp_file_path, str(output_path), bedrock_context)
            
            # Execute Q agent
            result = self._execute_q_agent("breakdown-agent", prompt)
            
            # Clean up temp file
            Path(temp_file_path).unlink(missing_ok=True)
            
            # Read generated JSON with better error handling
            if output_path.exists():
                try:
                    with open(output_path, 'r') as f:
                        content = f.read().strip()
                        if content:
                            # Try to clean and fix common JSON issues
                            cleaned_content = self._clean_json_content(content)
                            return json.loads(cleaned_content)
                        else:
                            print("Empty JSON file generated")
                            return self._generate_fallback_breakdown()
                except json.JSONDecodeError as e:
                    print(f"JSON decode error: {e}")
                    print(f"Raw content: {content[:200]}...")
                    # Try to extract JSON from the content
                    extracted_json = self._extract_json_from_content(content)
                    if extracted_json:
                        return extracted_json
                    return self._generate_fallback_breakdown()
            else:
                print("No output file generated by Q agent")
                return self._generate_fallback_breakdown()
                
        except Exception as e:
            print(f"Q Agent error: {e}")
            return self._generate_fallback_breakdown()
    
    def process_verification(self, request_id: int, design_content: str, bedrock_context: dict) -> dict:
        """Process design verification using Q agent"""
        try:
            output_path = self.config.OUTPUT_FOLDER / str(request_id) / "verification_data.json"
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            prompt = self._create_verification_prompt(design_content, str(output_path), bedrock_context)
            result = self._execute_q_agent("verify-agent", prompt)
            
            if output_path.exists():
                try:
                    with open(output_path, 'r') as f:
                        content = f.read().strip()
                        if content:
                            cleaned_content = self._clean_json_content(content)
                            return json.loads(cleaned_content)
                        else:
                            return self._generate_fallback_verification()
                except json.JSONDecodeError as e:
                    print(f"JSON decode error in verification: {e}")
                    extracted_json = self._extract_json_from_content(content)
                    if extracted_json:
                        return extracted_json
                    return self._generate_fallback_verification()
            else:
                return self._generate_fallback_verification()
                
        except Exception as e:
            print(f"Q Agent error: {e}")
            return self._generate_fallback_verification()
    
    def process_creation(self, request_id: int, acceptance_criteria: str, bedrock_context: dict) -> dict:
        """Process design document creation using Q agent"""
        try:
            output_path = self.config.OUTPUT_FOLDER / str(request_id) / "design_data.json"
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            prompt = self._create_creation_prompt(acceptance_criteria, str(output_path), bedrock_context)
            result = self._execute_q_agent("create-agent", prompt)
            
            if output_path.exists():
                try:
                    with open(output_path, 'r') as f:
                        content = f.read().strip()
                        if content:
                            cleaned_content = self._clean_json_content(content)
                            return json.loads(cleaned_content)
                        else:
                            return self._generate_fallback_creation()
                except json.JSONDecodeError as e:
                    print(f"JSON decode error in creation: {e}")
                    extracted_json = self._extract_json_from_content(content)
                    if extracted_json:
                        return extracted_json
                    return self._generate_fallback_creation()
            else:
                return self._generate_fallback_creation()
                
        except Exception as e:
            print(f"Q Agent error: {e}")
            return self._generate_fallback_creation()
    
    def process_chat(self, question: str, bedrock_context: dict) -> str:
        """Process chat question using Q agent"""
        try:
            prompt = self._create_chat_prompt(question, bedrock_context)
            result = self._execute_q_agent("chat-agent", prompt)
            
            if result.returncode == 0 and result.stdout.strip():
                return self._clean_response(result.stdout.strip())
            else:
                return self._generate_fallback_chat_response(question)
                
        except Exception as e:
            print(f"Q Agent error: {e}")
            return self._generate_fallback_chat_response(question)
    
    def _execute_q_agent(self, agent_name: str, prompt: str) -> subprocess.CompletedProcess:
        """Execute Q CLI agent with prompt"""
        cmd = ['q', 'chat', '--agent', agent_name, '--no-interactive', prompt]
        
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=str(self.config.BASE_DIR),
            timeout=30,
            input='\n'  # Send newline to handle any interactive prompts
        )
        
        return result
    
    def _create_breakdown_prompt(self, file_path: str, output_path: str, bedrock_context: dict) -> str:
        """Create breakdown prompt with Bedrock context"""
        return f"""
Please analyze the specification document at: {file_path}

Bedrock Context (similar breakdowns):
{json.dumps(bedrock_context, indent=2)}

Generate a spec breakdown following the patterns shown in the Bedrock context.

IMPORTANT: Save ONLY valid JSON to: {output_path}
The JSON must follow this EXACT structure:
{{
  "epic": "Epic Name Here",
  "stories": [
    {{
      "story_name": "Story Name",
      "acceptance_criteria": "**GIVEN**: condition **WHEN**: action **THEN**: result",
      "issue_type": "User Story",
      "points": ""
    }}
  ]
}}

Requirements:
1. Create 5-10 user stories
2. Use GIVEN/WHEN/THEN format for acceptance criteria
3. Set issue_type to either "User Story" or "Task"
4. Leave points empty
5. Output ONLY the JSON - no explanations, no markdown, no extra text
"""
    
    def _create_verification_prompt(self, design_content: str, output_path: str, bedrock_context: dict) -> str:
        """Create verification prompt with Bedrock context"""
        return f"""
Please verify this design document content:

{design_content}

Bedrock Context (existing designs):
{json.dumps(bedrock_context, indent=2)}

IMPORTANT: Save ONLY valid JSON to: {output_path}
The JSON must follow this EXACT structure:
{{
  "status": "verified",
  "missing_objects": ["object1", "object2"],
  "recommendations": ["recommendation1", "recommendation2"],
  "similar_designs": ["design1", "design2"]
}}

Output ONLY the JSON - no explanations, no markdown, no extra text.
"""
    
    def _create_creation_prompt(self, acceptance_criteria: str, output_path: str, bedrock_context: dict) -> str:
        """Create design creation prompt with Bedrock context"""
        return f"""
Please create a design document from these acceptance criteria:

{acceptance_criteria}

Bedrock Context (similar designs):
{json.dumps(bedrock_context, indent=2)}

IMPORTANT: Save ONLY valid JSON to: {output_path}
The JSON must follow this EXACT structure:
{{
  "design_document": {{
    "overview": "Design overview",
    "objects": [
      {{
        "name": "ObjectName",
        "type": "Service",
        "description": "Object description",
        "methods": ["method1", "method2"]
      }}
    ],
    "implementation_notes": ["note1", "note2"],
    "dependencies": ["dependency1", "dependency2"]
  }}
}}

Output ONLY the JSON - no explanations, no markdown, no extra text.
"""
    
    def _create_chat_prompt(self, question: str, bedrock_context: dict) -> str:
        """Create chat prompt with Bedrock context"""
        print(f"DEBUG: Bedrock context summary: {bedrock_context.get('summary', 'No summary')[:100]}")
        print(f"DEBUG: Bedrock results count: {len(bedrock_context.get('results', []))}")
        return f"""
User Question: {question}

Bedrock Context (relevant documents):
{json.dumps(bedrock_context, indent=2)}

Please answer the user's question based on the available context. Be helpful and conversational.
"""
    
    def _generate_fallback_breakdown(self) -> dict:
        """Generate fallback breakdown data"""
        return {
            "epic": "Feature Implementation",
            "stories": [
                {
                    "story_name": "Core Functionality",
                    "acceptance_criteria": "**GIVEN**: System is ready\n**WHEN**: User performs action\n**THEN**: Expected result occurs",
                    "issue_type": "User Story",
                    "points": ""
                }
            ]
        }
    
    def _generate_fallback_verification(self) -> dict:
        """Generate fallback verification data"""
        return {
            "status": "verified",
            "missing_objects": ["No specific issues identified"],
            "recommendations": ["Design appears complete based on available context"],
            "similar_designs": ["No similar designs found in context"]
        }
    
    def _generate_fallback_creation(self) -> dict:
        """Generate fallback creation data"""
        return {
            "design_document": {
                "overview": "Design document generated from acceptance criteria",
                "objects": [
                    {
                        "name": "MainService",
                        "type": "Service",
                        "description": "Core service handling main functionality",
                        "methods": ["processRequest", "validateInput", "generateResponse"]
                    }
                ],
                "implementation_notes": [
                    "Follow existing service patterns",
                    "Implement proper error handling",
                    "Add logging and monitoring"
                ],
                "dependencies": [
                    "Database connection",
                    "Authentication service",
                    "Logging framework"
                ]
            }
        }
    
    def _generate_fallback_chat_response(self, question: str) -> str:
        """Generate fallback chat response"""
        return f"I understand you're asking about: {question}. However, I don't have specific information available in the knowledge base to provide a detailed answer. Could you try rephrasing your question or provide more context?"
    
    def _clean_response(self, response: str) -> str:
        """Clean ANSI codes and unwanted characters from response"""
        import re
        # Remove ANSI color codes
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        cleaned = ansi_escape.sub('', response)
        
        # Remove other unwanted characters
        cleaned = cleaned.replace('mm mm', ' ')
        cleaned = cleaned.replace('10m"', '"')
        cleaned = cleaned.replace('m.mm', '.')
        cleaned = cleaned.replace('mm', '')
        
        # Clean up extra whitespace
        cleaned = ' '.join(cleaned.split())
        
        return cleaned
    
    def _clean_json_content(self, content: str) -> str:
        """Clean JSON content to fix common formatting issues"""
        import re
        
        # Remove ANSI codes
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        content = ansi_escape.sub('', content)
        
        # Remove markdown code blocks
        content = re.sub(r'```json\s*', '', content)
        content = re.sub(r'```\s*$', '', content)
        
        # Remove extra text before/after JSON
        content = content.strip()
        
        return content
    
    def _extract_json_from_content(self, content: str) -> dict:
        """Try to extract valid JSON from mixed content"""
        import re
        
        # Look for JSON object pattern
        json_pattern = r'\{.*\}'
        matches = re.findall(json_pattern, content, re.DOTALL)
        
        for match in matches:
            try:
                return json.loads(match)
            except json.JSONDecodeError:
                continue
        
        return None
